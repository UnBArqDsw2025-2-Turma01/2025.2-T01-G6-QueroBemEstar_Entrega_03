# 3.3.2. Observer
Este documento descreve a implementa√ß√£o do Padr√£o de Projeto Comportamental Observer, aplicado ao sistema de notifica√ß√£o da aplica√ß√£o.

## Princ√≠pios e Vantagens
A ado√ß√£o do padr√£o Observer traz diversos benef√≠cios alinhados aos princ√≠pios de bom design de software:
- **Desacoplamento:** O `Subject` (observado) n√£o conhece as classes concretas de seus `Observers` (observadores), apenas a interface. Isso permite que os "publicadores" (como `Receita`) e os "assinantes" (como `Usuario`) evoluam de forma independente.
- **Flexibilidade e Extensibilidade:** Novos `Observers` (ouvintes) podem ser adicionados ou removidos do `Subject` a qualquer momento, sem a necessidade de modificar o c√≥digo do `Subject`.
- **Responsabilidade √önica:** O `Subject` foca em manter seu estado e notificar sobre mudan√ßas. O `Observer` foca em como reagir a essas mudan√ßas, separando as l√≥gicas de neg√≥cio.
- **Comunica√ß√£o Broadcast:** Permite que uma √∫nica mudan√ßa de estado em um objeto seja eficientemente transmitida (broadcast) para m√∫ltiplos objetos interessados (uma rela√ß√£o "um-para-muitos").


## Casos de Uso

##### ‚úÖ Quando usar Observer?
O padr√£o Observer √© indicado quando: ¬†
- Uma mudan√ßa no estado de um objeto (`Subject`) requer que outros objetos (`Observers`) sejam informados. ¬†
- Queremos que um objeto possa notificar outros sem estar fortemente acoplado a eles (ex: `Receita` notificando `Usuario` sobre um coment√°rio). ¬†
- O n√∫mero de objetos que precisam ser notificados pode mudar dinamicamente em tempo de execu√ß√£o.

##### üö´ Quando N√ÉO usar?
Evite o padr√£o Observer quando:
- A comunica√ß√£o √© simples, s√≠ncrona e sempre entre os mesmos dois objetos (uma chamada de m√©todo direta √© mais simples).
- O `Subject` precisa saber exatamente quem √© o `Observer` e chamar m√©todos espec√≠ficos dele que n√£o est√£o na interface.
- A adi√ß√£o do padr√£o cria uma complexidade desnecess√°ria para uma simples atualiza√ß√£o de campo (over-engineering).

## Estrutura do Observer

A estrutura do Observer (Modelo Push) envolve:

1.  **Subject (interface):** define os m√©todos que o objeto observ√°vel ("publicador") deve implementar (`adicionarObservador`, `removerObservador`, `notificar`). ¬†
2.  **Observer (interface):** define o m√©todo de atualiza√ß√£o que o observador ("ouvinte") deve implementar (`atualizar`). ¬†
3.  **ConcreteSubject (concreto):** implementa a interface `Subject`, mant√©m a lista de observadores e chama `notificar()` quando seu estado muda (ex: `Receita`, `Competicao`, `CheckIn`, `Usuario`).
4.  **ConcreteObserver (concreto):** implementa a interface `Observer` e define a a√ß√£o a ser tomada quando seu m√©todo `atualizar()` √© chamado (ex: `Usuario`).

## 1. Modelagem no Projeto
O padr√£o **Observer** foi implementado para resolver o problema de notificar um objeto sobre mudan√ßas no estado de outro, garantindo um baixo acoplamento entre eles.

No projeto, a classe `Usuario` precisa ser informada em tempo real quando diversos eventos ocorrem, como receber um novo coment√°rio em uma `Receita`, ganhar um `NOVO_SEGUIDOR` (um evento relacionado a pr√≥pria classe usu√°rio), ou quando o `Ranking` de uma `Competicao` √© atualizado.

Para evitar que as classes `Subject` (como `Receita`) tivessem uma depend√™ncia direta e "tivessem conhecimento" sobre a classe `Usuario` (o que violaria o Princ√≠pio Aberto/Fechado), foi implementado um mecanismo de assinatura para as interfaces (`Object` e `Subject`). Foi utilizado o **Modelo Push**, onde o `Subject` "empurra" os dados da notifica√ß√£o para os `Observers`.

* **A Interface (Sujeito):** A `Subject` √© o "contrato" que define que todo objeto observ√°vel deve ter os m√©todos `adicionarObservador(Observer o)`, `removerObservador(Observer o)` e `notificar(TipoNotificacao tipo, Object dados)`.

* **A Interface (Observador):** A `Observer` √© o "contrato" que define que todo objeto assinante deve ter um m√©todo `atualizar(TipoNotificacao tipo, Object dados)`.

* **Os Sujeitos Concretos:** As classes `Receita`, `Competicao`, `CheckIn` e a pr√≥pria `Usuario` implementam a interface `Subject`. Cada uma √© respons√°vel por manter sua pr√≥pria lista de observadores e chamar seu m√©todo `notificar()` quando um gatilho interno ocorre (ex: a `Receita` chama `notificar()` dentro do seu m√©todo `adicionarComentario`).

* **O Observador Concreto:** A classe `Usuario` √© o principal e √∫nico observador concreto, implementando a interface `Observer`. Seu m√©todo `atualizar()` √© o receptor central que "ouve" as notifica√ß√µes de todos os Sujeitos que ele assina, recebe os dados (`tipo` e `dados`) e processa a notifica√ß√£o.

## 2. Diagrama UML
O diagrama abaixo ilustra a rela√ß√£o entre as classes:

![Diagrama de Classes UML do Padr√£o Strategy](../assets/Observer.jpeg)
<center>
<p style="text-align: center"><b>Figura 1:</b> Diagrama UML Observer</p>

<b>Autor(es):</b>  <a href="https://github.com/SAnjos3" target="_blank">Gabriel Soares dos Anjos</a>, <a href="https://github.com/fbressa" target="_blank">Filipe Bressanelli</a>, <a href="https://github.com/eduardoferre" target="_blank">Eduardo Ferreira</a>. 2025
<br>Link Artefato: <a href="https://lucid.app/lucidspark/9d94d4cd-d376-4c12-ac39-d209063a5b1f/edit?invitationId=inv_af100e84-6237-43c2-8b79-1792b09b3f12&page=0_0#" target="_blank">Draw.io</a>
</p>
</font> 
</center>
## 3. Implementa√ß√£o

A implementa√ß√£o foi dividida em uma estrutura de pastas para melhor organiza√ß√£o.

### 3.1 Interfaces

As interfaces `Subject` e `Observer` definem o contrato do padr√£o e est√£o localizadas na pasta `src/interfaces`.

**`observer/src/interfaces/Subject.ts`**
```typescript
import { TipoNotificacao } from "../domain/TipoNotificacao";
import { Observer } from "./Observer";

export interface Subject {
    adicionarObservador(o: Observer): void;
    removerObservador(o: Observer): void;
    notificar(tipo: TipoNotificacao, dados: any): void;
}
```

**`observer/src/interfaces/Observer.ts`**
```typescript
import { TipoNotificacao } from "../domain/TipoNotificacao";

export interface Observer {
    atualizar(tipo: TipoNotificacao, dados: any): void;
}
```

### 3.2 Classes Concretas

As classes que implementam as interfaces `Subject` e `Observer` est√£o na pasta `src/concrete`.

#### 3.2.1 Classe usu√°rio

**`observer/src/concrete/Usuario.ts`**
```typescript
import { Observer } from "../interfaces/Observer";
import { Subject } from "../interfaces/Subject";
import { TipoNotificacao } from "../domain/TipoNotificacao";
import { Receita } from "./Receita";
import { CheckIn } from "./CheckIn";

export class Usuario implements Observer, Subject {
    private nome: string;
    private observadores: Observer[] = [];

    constructor(nome: string) {
        this.nome = nome;
    }

    // --- Implementa√ß√£o como OBSERVER (Ouvinte) ---
    atualizar(tipo: TipoNotificacao, dados: any): void {
        console.log(`  -> Notifica√ß√£o para ${this.nome}: ${tipo} - ${dados}`);
    }

    // --- Implementa√ß√£o como SUBJECT (Falante) ---
    adicionarObservador(o: Observer): void {
        // ...
    }

    removerObservador(o: Observer): void {
        // ...
    }

    notificar(tipo: TipoNotificacao, dados: any): void {
        // ...
    }

    // --- M√©todos de A√ß√£o (O que o Usu√°rio FAZ) ---
    seguir(usuarioAlvo: Usuario): void {
        console.log(`\n--- A√ß√£o: ${this.nome} seguiu ${usuarioAlvo.getNome()} ---`);
        usuarioAlvo.serSeguidoPor(this);
    }
    
    // ... outros m√©todos de a√ß√£o

    // --- M√©todos "Gatilho" (O que ACONTECE com o Usu√°rio) ---
    serSeguidoPor(novoSeguidor: Usuario): void {
        console.log(`[GATILHO NO USU√ÅRIO ${this.nome}]: Notificando observadores...`);
        this.notificar(TipoNotificacao.NOVO_SEGUIDOR, `${novoSeguidor.getNome()} come√ßou a seguir voc√™.`);
    }
}
```

#### 3.2.2 Classe Receita

**`observer/src/concrete/Receita.ts`**
```typescript
import { Subject } from "../interfaces/Subject";
// ... outras importa√ß√µes

export class Receita implements Subject {
    private titulo: string;
    private observadores: Observer[] = [];

    // ... construtor e m√©todos de Subject

    // --- M√©todos "Gatilho" ---
    adicionarCurtida(autorDaCurtida: Usuario): void {
        console.log(`[GATILHO NA RECEITA ${this.titulo}]: Notificando observadores...`);
        this.notificar(TipoNotificacao.CURTIDA_RECEITA, `${autorDaCurtida.getNome()} curtiu sua receita.`);
    }

    adicionarComentario(comentario: string, autorDoComentario: Usuario): void {
        console.log(`[GATILHO NA RECEITA ${this.titulo}]: Notificando observadores...`);
        this.notificar(TipoNotificacao.COMENTARIO_RECEITA, `${autorDoComentario.getNome()} comentou: ${comentario}`);
    }
}
```

As classes `CheckIn` e `Ranking` seguem uma estrutura semelhante.

### 3.3 C√≥digo de Execu√ß√£o

O arquivo principal que orquestra e demonstra o padr√£o est√° em `src/main.ts`.

**`observer/src/main.ts`**
```typescript
import { Usuario } from "./concrete/Usuario";
import { Receita } from "./concrete/Receita";
import { CheckIn } from "./concrete/CheckIn";
import { Ranking } from "./concrete/Ranking";

function main(): void {
    // --- 1. Criar os objetos concretos ---
    const autorReceita = new Usuario("ChefAna");
    const leitor = new Usuario("LeitorBob");

    const receitaDeBolo = new Receita("Bolo de Chocolate");
    const checkin101 = new CheckIn(101);
    const rankingCompeticao = new Ranking(1);

    // --- 2. Fazer as inscri√ß√µes (Ligar os fios) ---
    receitaDeBolo.adicionarObservador(autorReceita);
    checkin101.adicionarObservador(autorReceita);
    rankingCompeticao.adicionarObservador(autorReceita);
    autorReceita.adicionarObservador(autorReceita);

    console.log("--- Fluxo de Notifica√ß√£o Iniciado ---");

    // --- 3. A√ß√µes (Disparar os gatilhos) ---
    leitor.comentar(receitaDeBolo, "Que del√≠cia!");
    leitor.seguir(autorReceita);
    leitor.curtir(receitaDeBolo);
    leitor.comentarCheckIn(checkin101, "√ìtimo lugar!");
    rankingCompeticao.atualizarRanking();
}

// Executar a fun√ß√£o main
main();
```

## 4. Como Rodar o Projeto

O projeto agora est√° estruturado com `npm` para gerenciar depend√™ncias e scripts. Siga os passos abaixo para executar o c√≥digo.

### 4.1. Pr√©-requisitos (Depend√™ncias)

- **Node.js e npm:** Certifique-se de ter o [Node.js](https://nodejs.org/) instalado, que inclui o `npm`.

As depend√™ncias do projeto, como `typescript` e `ts-node`, est√£o listadas no arquivo `package.json` e ser√£o instaladas automaticamente.

### 4.2. Passo a Passo para Execu√ß√£o

1.  **Navegue at√© a pasta do projeto:**
    Abra um terminal e navegue at√© a pasta `observer`.
    ```sh
    cd observer
    ```

2.  **Instale as depend√™ncias:**
    Execute o comando abaixo para instalar todos os pacotes necess√°rios que est√£o definidos no `package.json`. Este comando √© an√°logo a `pip install -r requirements.txt` em Python.
    ```sh
    npm install
    ```

3.  **Execute o c√≥digo:**
    Utilize o script `start` configurado no `package.json` para compilar e rodar o arquivo `main.ts`.
    ```sh
    npm start
    ```

## V√≠deo Apresenta√ß√£o
<iframe src="https://unbbr.sharepoint.com/sites/G6/_layouts/15/embed.aspx?UniqueId=0eb4a061-4487-40d8-94cf-dc016658de76&embed=%7B%22ust%22%3Atrue%2C%22hv%22%3A%22CopyEmbedCode%22%7D&referrer=StreamWebApp&referrerScenario=EmbedDialog.Create" width="640" height="360" frameborder="0" scrolling="no" allowfullscreen title="Reuni√£o em separador 1-20251021_203748-Grava√ß√£o de Reuni√£o.mp4"></iframe>

## Refer√™ncias Bibliograficas
> REFACTORING GURU. Design Patterns. Dispon√≠vel em: <https://refactoring.guru/design-patterns>. Acesso em: 23 out. 2025.

> SERRANO, Milene. AULA - GOFs Comportamentais. [Apresenta√ß√£o de slides utilizada na disciplina de Arquitetura e Desenho de Software] ‚Äì [Universidade de Basilia], 2025.
>
## Tabela de Participa√ß√£o do Projeto

| Integrante            | Contribui√ß√µes Principais                                                                                                                                                                      |
| --------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **Gabriel Soares**    | Estrutura√ß√£o do arquivo, cria√ß√£o e formata√ß√£o do documento em Markdown, elabora√ß√£o e desenvolvimento do padr√£o comportamental Observer, ajustes de estilo e revis√£o final de todo o conte√∫do. |
| **Felipe Bressaneli** | Contribuiu no desenvolvimento  e revis√£o do padr√£o e na cria√ß√£o do diagramas UML correspondente                                                                                               |
| **Eduardo Ferreira**  | Contribuiu no desenvolvimento e revis√£o do padr√£o e na cria√ß√£o do diagramas UML correspondente                                                                                                |


## 7. Hist√≥rico de Vers√£o


| Vers√£o | Data       | Altera√ß√£o            | Respons√°vel                   | Revisor | Data de revis√£o |
| ------ | ---------- | -------------------- | ----------------------------- | ------- | --------------- |
| 1.0    | 22/10/2025 | Cria√ß√£o do documento | [Gabriel](github.com/SAnjos3) |         | 23/10/2025      |