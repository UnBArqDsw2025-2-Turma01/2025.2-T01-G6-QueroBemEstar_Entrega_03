# 3.3.2 Padr√£o de Projeto: Observer
Este documento descreve a implementa√ß√£o do Padr√£o de Projeto Comportamental Observer, aplicado ao sistema de notifica√ß√£o da aplica√ß√£o.

## Princ√≠pios e Vantagens
A ado√ß√£o do padr√£o Observer traz diversos benef√≠cios alinhados aos princ√≠pios de bom design de software:
- **Desacoplamento:** O `Subject` (observado) n√£o conhece as classes concretas de seus `Observers` (observadores), apenas a interface. Isso permite que os "publicadores" (como `Receita`) e os "assinantes" (como `Usuario`) evoluam de forma independente.
- **Flexibilidade e Extensibilidade:** Novos `Observers` (ouvintes) podem ser adicionados ou removidos do `Subject` a qualquer momento, sem a necessidade de modificar o c√≥digo do `Subject`.
- **Responsabilidade √önica:** O `Subject` foca em manter seu estado e notificar sobre mudan√ßas. O `Observer` foca em como reagir a essas mudan√ßas, separando as l√≥gicas de neg√≥cio.
- **Comunica√ß√£o Broadcast:** Permite que uma √∫nica mudan√ßa de estado em um objeto seja eficientemente transmitida (broadcast) para m√∫ltiplos objetos interessados (uma rela√ß√£o "um-para-muitos").


## Casos de Uso

##### ‚úÖ Quando usar Observer?
O padr√£o Observer √© indicado quando: ¬†
- Uma mudan√ßa no estado de um objeto (`Subject`) requer que outros objetos (`Observers`) sejam informados. ¬†
- Queremos que um objeto possa notificar outros sem estar fortemente acoplado a eles (ex: `Receita` notificando `Usuario` sobre um coment√°rio). ¬†
- O n√∫mero de objetos que precisam ser notificados pode mudar dinamicamente em tempo de execu√ß√£o.

##### üö´ Quando N√ÉO usar?
Evite o padr√£o Observer quando:
- A comunica√ß√£o √© simples, s√≠ncrona e sempre entre os mesmos dois objetos (uma chamada de m√©todo direta √© mais simples).
- O `Subject` precisa saber exatamente quem √© o `Observer` e chamar m√©todos espec√≠ficos dele que n√£o est√£o na interface.
- A adi√ß√£o do padr√£o cria uma complexidade desnecess√°ria para uma simples atualiza√ß√£o de campo (over-engineering).

## Estrutura do Observer

A estrutura do Observer (Modelo Push) envolve:

1.  **Subject (interface):** define os m√©todos que o objeto observ√°vel ("publicador") deve implementar (`adicionarObservador`, `removerObservador`, `notificar`). ¬†
2.  **Observer (interface):** define o m√©todo de atualiza√ß√£o que o observador ("ouvinte") deve implementar (`atualizar`). ¬†
3.  **ConcreteSubject (concreto):** implementa a interface `Subject`, mant√©m a lista de observadores e chama `notificar()` quando seu estado muda (ex: `Receita`, `Competicao`, `CheckIn`, `Usuario`).
4.  **ConcreteObserver (concreto):** implementa a interface `Observer` e define a a√ß√£o a ser tomada quando seu m√©todo `atualizar()` √© chamado (ex: `Usuario`).

## 1. Modelagem no Projeto
O padr√£o **Observer** foi implementado para resolver o problema de notificar um objeto sobre mudan√ßas no estado de outro, garantindo um baixo acoplamento entre eles.

No projeto, a classe `Usuario` precisa ser informada em tempo real quando diversos eventos ocorrem, como receber um novo coment√°rio em uma `Receita`, ganhar um `NOVO_SEGUIDOR` (um evento relacionado a pr√≥pria classe usu√°rio), ou quando o `Ranking` de uma `Competicao` √© atualizado.

Para evitar que as classes `Subject` (como `Receita`) tivessem uma depend√™ncia direta e "tivessem conhecimento" sobre a classe `Usuario` (o que violaria o Princ√≠pio Aberto/Fechado), foi implementado um mecanismo de assinatura para as interfaces (`Object` e `Subject`). Foi utilizado o **Modelo Push**, onde o `Subject` "empurra" os dados da notifica√ß√£o para os `Observers`.

* **A Interface (Sujeito):** A `Subject` √© o "contrato" que define que todo objeto observ√°vel deve ter os m√©todos `adicionarObservador(Observer o)`, `removerObservador(Observer o)` e `notificar(TipoNotificacao tipo, Object dados)`.

* **A Interface (Observador):** A `Observer` √© o "contrato" que define que todo objeto assinante deve ter um m√©todo `atualizar(TipoNotificacao tipo, Object dados)`.

* **Os Sujeitos Concretos:** As classes `Receita`, `Competicao`, `CheckIn` e a pr√≥pria `Usuario` implementam a interface `Subject`. Cada uma √© respons√°vel por manter sua pr√≥pria lista de observadores e chamar seu m√©todo `notificar()` quando um gatilho interno ocorre (ex: a `Receita` chama `notificar()` dentro do seu m√©todo `adicionarComentario`).

* **O Observador Concreto:** A classe `Usuario` √© o principal e √∫nico observador concreto, implementando a interface `Observer`. Seu m√©todo `atualizar()` √© o receptor central que "ouve" as notifica√ß√µes de todos os Sujeitos que ele assina, recebe os dados (`tipo` e `dados`) e processa a notifica√ß√£o.

## 2. Diagrama UML
O diagrama abaixo ilustra a rela√ß√£o entre as classes:

![Diagrama de Classes UML do Padr√£o Strategy](../assets/Observer.jpeg)
<center>
<p style="text-align: center"><b>Figura 1:</b> Diagrama UML Observer</p>

<b>Autor(es):</b>  <a href="https://github.com/SAnjos3" target="_blank">Gabriel Soares dos Anjos</a>, <a href="https://github.com/fbressa" target="_blank">Filipe Bressanelli</a>, <a href="https://github.com/eduardoferre" target="_blank">Eduardo Ferreira</a>. 2025
<br>Link Artefato: <a href="https://lucid.app/lucidspark/9d94d4cd-d376-4c12-ac39-d209063a5b1f/edit?invitationId=inv_af100e84-6237-43c2-8b79-1792b09b3f12&page=0_0#" target="_blank">Draw.io</a>
</p>
</font> 
</center>
## 3. Implementa√ß√£o

### 3.1 Interfaces
```typescript
// Interface (Contrato) Subject
interface Subject {
    adicionarObservador(o: Observer): void;
    removerObservador(o: Observer): void;
    notificar(tipo: TipoNotificacao, dados: any): void;
}

// Interface (Contrato) Observer
interface Observer {
    atualizar(tipo: TipoNotificacao, dados: any): void;
}
```

### 3.2 Classes Concretas

#### 3.2.1 Classe usu√°rio
```typescript
// Implementa√ß√£o contratos Usuario
class Usuario implements Observer, Subject {
    private nome: string;
    private observadores: Observer[] = [];

    constructor(nome: string) {
        this.nome = nome;
    }

    getNome(): string {
        return this.nome;
    }

    // --- Parte 1: Implementa√ß√£o como OBSERVER (Ouvinte) ---
    atualizar(tipo: TipoNotificacao, dados: any): void {
        // Local onde a notifica√ß√£o chega
        console.log(`  -> Notifica√ß√£o para ${this.nome}: ${tipo} - ${dados}`);
    }

    // --- Parte 2: Implementa√ß√£o como SUBJECT (Falante) ---
    adicionarObservador(o: Observer): void {
        if (o !== null && !this.observadores.includes(o)) {
            this.observadores.push(o);
        }
    }

    removerObservador(o: Observer): void {
        const index = this.observadores.indexOf(o);
        if (index > -1) {
            this.observadores.splice(index, 1);
        }
    }

    notificar(tipo: TipoNotificacao, dados: any): void {
        for (const obs of this.observadores) {
            obs.atualizar(tipo, dados);
        }
    }

    //  M√©todos de A√ß√£o (O que o Usu√°rio FAZ)

    // A√ß√£o: Seguir outro usu√°rio
    seguir(usuarioAlvo: Usuario): void {
        console.log(`\n--- A√ß√£o: ${this.nome} seguiu ${usuarioAlvo.getNome()} ---`);
        // Chama o gatilho no usu√°rio-alvo
        usuarioAlvo.serSeguidoPor(this);
    }

    // A√ß√£o: Curtir uma receita
    curtir(receitaAlvo: Receita): void {
        console.log(`\n--- A√ß√£o: ${this.nome} curtiu a receita '${receitaAlvo.getTitulo()}' ---`);
        // Chama o gatilho na receita-alvo
        receitaAlvo.adicionarCurtida(this);
    }

    // A√ß√£o: Comentar em uma receita
    comentar(receitaAlvo: Receita, comentario: string): void {
        console.log(`\n--- A√ß√£o: ${this.nome} comentou na receita '${receitaAlvo.getTitulo()}' ---`);
        // Chama o gatilho" na receita-alvo
        receitaAlvo.adicionarComentario(comentario, this);
    }

    // A√ß√£o: Comentar em um Check-In
    comentarCheckIn(checkInAlvo: CheckIn, comentario: string): void {
        console.log(`\n--- A√ß√£o: ${this.nome} comentou no Check-In ID: ${checkInAlvo.getIdCheckIn()} ---`);
        // Chama o gatilho no checkIn-alvo
        checkInAlvo.adicionarComentario(comentario, this);
    }

 // M√©todos Gatilho

    // Gatilho: Este usu√°rio √© seguido por algu√©m
    serSeguidoPor(novoSeguidor: Usuario): void {
        // 1. L√≥gica interna ....

        // 2. Chamar o notificar para avisar os observadores
        console.log(`[GATILHO NO USU√ÅRIO ${this.nome}]: Notificando observadores...`);
        this.notificar(TipoNotificacao.NOVO_SEGUIDOR, `${novoSeguidor.getNome()} come√ßou a seguir voc√™.`);
    }
}
```

#### 3.2.2 Classe Receita
```typescript
class Receita implements Subject {
    private titulo: string;
    private observadores: Observer[] = [];

    constructor(titulo: string) {
        this.titulo = titulo;
    }

    getTitulo(): string {
        return this.titulo;
    }

    adicionarObservador(o: Observer): void {
        if (o !== null && !this.observadores.includes(o)) {
            this.observadores.push(o);
        }
    }

    removerObservador(o: Observer): void {
        const index = this.observadores.indexOf(o);
        if (index > -1) {
            this.observadores.splice(index, 1);
        }
    }

    notificar(tipo: TipoNotificacao, dados: any): void {
        for (const obs of this.observadores) {
            obs.atualizar(tipo, dados);
        }
    }

    // --- M√©todos Gatilho ---

    adicionarCurtida(autorDaCurtida: Usuario): void {
        // 1. L√≥gica interna ....

        // 2. Chamar o notificar para avisar os observadores
        console.log(`[GATILHO NA RECEITA ${this.titulo}]: Notificando observadores...`);
        this.notificar(TipoNotificacao.CURTIDA_RECEITA, `${autorDaCurtida.getNome()} curtiu sua receita.`);
    }

    adicionarComentario(comentario: string, autorDoComentario: Usuario): void {
        // 1. L√≥gica interna ....

        // 2. Chamar o notificar para avisar os observadores
        console.log(`[GATILHO NA RECEITA ${this.titulo}]: Notificando observadores...`);
        this.notificar(TipoNotificacao.COMENTARIO_RECEITA, `${autorDoComentario.getNome()} comentou: ${comentario}`);
    }
}
```

#### 3.2.3 Classe CheckIn
```typescript
class CheckIn implements Subject {
    private idCheckIn: number;
    private observadores: Observer[] = [];

    constructor(id: number) {
        this.idCheckIn = id;
    }

    getIdCheckIn(): number {
        return this.idCheckIn;
    }

    adicionarObservador(o: Observer): void {
        if (o !== null && !this.observadores.includes(o)) {
            this.observadores.push(o);
        }
    }

    removerObservador(o: Observer): void {
        const index = this.observadores.indexOf(o);
        if (index > -1) {
            this.observadores.splice(index, 1);
        }
    }

    notificar(tipo: TipoNotificacao, dados: any): void {
        for (const obs of this.observadores) {
            obs.atualizar(tipo, dados);
        }
    }

    // --- M√©todo "Gatilho" ---
    adicionarComentario(comentario: string, autorDoComentario: Usuario): void {
        // 1. L√≥gica interna ....

        // 2. Chamar o notificar para avisar os observadores
        console.log(`[GATILHO NO CHECKIN ${this.idCheckIn}]: Notificando observadores...`);
        this.notificar(TipoNotificacao.COMENTARIO_CHECKIN, `${autorDoComentario.getNome()} comentou no seu Check-In.`);
    }
}

```

#### 3.2.4 Classe Ranking
```typescript
class Ranking implements Subject {
    private IdCompeticao: number;
    private observadores: Observer[] = [];

    constructor(id: number) {
        this.IdCompeticao = id;
    }

    adicionarObservador(o: Observer): void {
        if (o !== null && !this.observadores.includes(o)) {
            this.observadores.push(o);
        }
    }

    removerObservador(o: Observer): void {
        const index = this.observadores.indexOf(o);
        if (index > -1) {
            this.observadores.splice(index, 1);
        }
    }

    notificar(tipo: TipoNotificacao, dados: any): void {
        for (const obs of this.observadores) {
            obs.atualizar(tipo, dados);
        }
    }

    // --- M√©todo "Gatilho" ---
    atualizarRanking(): void {
        // 1. L√≥gica interna (buscar dados, recalcular)

        // 2. Chamar o notificar!
        console.log(`\n[GATILHO NO RANKING ${this.IdCompeticao}]: Notificando observadores...`);
        this.notificar(TipoNotificacao.ATUALIZACAO_RANKING, `O ranking da competi√ß√£o ${this.IdCompeticao} foi atualizado.`);
    }
}
```

### 3.3 C√≥digo Execu√ß√£o
```typescript
function main(): void {
    // --- 1. Criar os objetos concretos ---
    const autorReceita = new Usuario("ChefAna");
    const leitor = new Usuario("LeitorBob");

    const receitaDeBolo = new Receita("Bolo de Chocolate");
    const checkin101 = new CheckIn(101);
    const rankingCompeticao = new Ranking(1);

    // --- 2. Fazer as inscri√ß√µes (Ligar os fios) ---
    // ChefAna quer ser notificada sobre sua receita
    receitaDeBolo.adicionarObservador(autorReceita);

    // ChefAna quer ser notificada sobre seu check-in
    checkin101.adicionarObservador(autorReceita);

    // ChefAna quer ser notificada sobre o ranking
    rankingCompeticao.adicionarObservador(autorReceita);

    // ChefAna quer ser notificada quando algu√©m a seguir
    autorReceita.adicionarObservador(autorReceita);

    console.log("--- Fluxo de Notifica√ß√£o Iniciado ---");

    // --- 3. A√ß√µes (Disparar os gatilhos) ---

    // A√ß√£o 1: Leitor comenta na receita
    leitor.comentar(receitaDeBolo, "Que del√≠cia!");

    // A√ß√£o 2: Leitor segue o autor
    leitor.seguir(autorReceita);

    // A√ß√£o 3: Leitor curte a receita
    leitor.curtir(receitaDeBolo);

    // A√ß√£o 4: Leitor comenta no check-in
    leitor.comentarCheckIn(checkin101, "√ìtimo lugar!");

    // A√ß√£o 5: O ranking √© atualizado
    rankingCompeticao.atualizarRanking();
}

// Executar a fun√ß√£o main
main();
```

## 4. Depend√™ncias

Para rodar:

- **Node.js** (que inclui o npm)
- **TypeScript**
- **ts-node** (para executar o TypeScript diretamente)


## 5. Como Rodar
```ts
npx ts-node observer.ts
```
## V√≠deo Apresenta√ß√£o
<iframe src="https://unbbr.sharepoint.com/sites/G6/_layouts/15/embed.aspx?UniqueId=0eb4a061-4487-40d8-94cf-dc016658de76&embed=%7B%22ust%22%3Atrue%2C%22hv%22%3A%22CopyEmbedCode%22%7D&referrer=StreamWebApp&referrerScenario=EmbedDialog.Create" width="640" height="360" frameborder="0" scrolling="no" allowfullscreen title="Reuni√£o em separador 1-20251021_203748-Grava√ß√£o de Reuni√£o.mp4"></iframe>

## Refer√™ncias Bibliograficas
> REFACTORING GURU. Design Patterns. Dispon√≠vel em: <https://refactoring.guru/design-patterns>. Acesso em: 23 out. 2025.

> SERRANO, Milene. AULA - GOFs Comportamentais. [Apresenta√ß√£o de slides utilizada na disciplina de Arquitetura e Desenho de Software] ‚Äì [Universidade de Basilia], 2025.
>
## Tabela de Participa√ß√£o do Projeto

| Integrante            | Contribui√ß√µes Principais                                                                                                                                                                      |
| --------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **Gabriel Soares**    | Estrutura√ß√£o do arquivo, cria√ß√£o e formata√ß√£o do documento em Markdown, elabora√ß√£o e desenvolvimento do padr√£o comportamental Observer, ajustes de estilo e revis√£o final de todo o conte√∫do. |
| **Felipe Bressaneli** | Contribuiu no desenvolvimento  e revis√£o do padr√£o e na cria√ß√£o do diagramas UML correspondente                                                                                               |
| **Eduardo Ferreira**  | Contribuiu no desenvolvimento e revis√£o do padr√£o e na cria√ß√£o do diagramas UML correspondente                                                                                                |


## 7. Hist√≥rico de Vers√£o


| Vers√£o | Data       | Altera√ß√£o            | Respons√°vel                   | Revisor | Data de revis√£o |
| ------ | ---------- | -------------------- | ----------------------------- | ------- | --------------- |
| 1.0    | 22/10/2025 | Cria√ß√£o do documento | [Gabriel](github.com/SAnjos3) |         | 23/10/2025      |