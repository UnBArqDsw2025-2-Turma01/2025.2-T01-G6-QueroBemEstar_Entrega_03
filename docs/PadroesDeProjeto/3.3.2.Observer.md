# 3.3.2 Padrão de Projeto: Observer
Este documento descreve a implementação do Padrão de Projeto Comportamental Observer, aplicado ao sistema de notificação da aplicação.

## 1. O que foi feito

O padrão **Observer** foi implementado para resolver o problema de notificar um objeto sobre mudanças no estado de outro, garantindo um baixo acoplamento entre eles.

No projeto, a classe `Usuario` precisa ser informada em tempo real quando diversos eventos ocorrem, como receber um novo comentário em uma `Receita`, ganhar um `NOVO_SEGUIDOR` (um evento relacionado a própria classe usuário), ou quando o `Ranking` de uma `Competicao` é atualizado.

Para evitar que as classes `Subject` (como `Receita`) tivessem uma dependência direta e "tivessem conhecimento" sobre a classe `Usuario` (o que violaria o Princípio Aberto/Fechado), foi implementado um mecanismo de assinatura para as interfaces (`Object` e `Subject`). Foi utilizado o **Modelo Push**, onde o `Subject` "empurra" os dados da notificação para os `Observers`.

* **A Interface (Sujeito):** A `Subject` é o "contrato" que define que todo objeto observável deve ter os métodos `adicionarObservador(Observer o)`, `removerObservador(Observer o)` e `notificar(TipoNotificacao tipo, Object dados)`.

* **A Interface (Observador):** A `Observer` é o "contrato" que define que todo objeto assinante deve ter um método `atualizar(TipoNotificacao tipo, Object dados)`.

* **Os Sujeitos Concretos:** As classes `Receita`, `Competicao`, `CheckIn` e a própria `Usuario` implementam a interface `Subject`. Cada uma é responsável por manter sua própria lista de observadores e chamar seu método `notificar()` quando um gatilho interno ocorre (ex: a `Receita` chama `notificar()` dentro do seu método `adicionarComentario`).

* **O Observador Concreto:** A classe `Usuario` é o principal e único observador concreto, implementando a interface `Observer`. Seu método `atualizar()` é o receptor central que "ouve" as notificações de todos os Sujeitos que ele assina, recebe os dados (`tipo` e `dados`) e processa a notificação.

## 2. Diagrama UML
O diagrama abaixo ilustra a relação entre as classes:

![Diagrama de Classes UML do Padrão Strategy](../assets/Observer.jpeg)


## 3. Implementação

### 3.1 Interfaces
```typescript
// Interface (Contrato) Subject
interface Subject {
    adicionarObservador(o: Observer): void;
    removerObservador(o: Observer): void;
    notificar(tipo: TipoNotificacao, dados: any): void;
}

// Interface (Contrato) Observer
interface Observer {
    atualizar(tipo: TipoNotificacao, dados: any): void;
}
```

### 3.2 Classes Concretas

#### 3.2.1 Classe usuário
```typescript
// Implementação contratos Usuario
class Usuario implements Observer, Subject {
    private nome: string;
    private observadores: Observer[] = [];

    constructor(nome: string) {
        this.nome = nome;
    }

    getNome(): string {
        return this.nome;
    }

    // --- Parte 1: Implementação como OBSERVER (Ouvinte) ---
    atualizar(tipo: TipoNotificacao, dados: any): void {
        // Local onde a notificação chega
        console.log(`  -> Notificação para ${this.nome}: ${tipo} - ${dados}`);
    }

    // --- Parte 2: Implementação como SUBJECT (Falante) ---
    adicionarObservador(o: Observer): void {
        if (o !== null && !this.observadores.includes(o)) {
            this.observadores.push(o);
        }
    }

    removerObservador(o: Observer): void {
        const index = this.observadores.indexOf(o);
        if (index > -1) {
            this.observadores.splice(index, 1);
        }
    }

    notificar(tipo: TipoNotificacao, dados: any): void {
        for (const obs of this.observadores) {
            obs.atualizar(tipo, dados);
        }
    }

    //  Métodos de Ação (O que o Usuário FAZ)

    // Ação: Seguir outro usuário
    seguir(usuarioAlvo: Usuario): void {
        console.log(`\n--- Ação: ${this.nome} seguiu ${usuarioAlvo.getNome()} ---`);
        // Chama o gatilho no usuário-alvo
        usuarioAlvo.serSeguidoPor(this);
    }

    // Ação: Curtir uma receita
    curtir(receitaAlvo: Receita): void {
        console.log(`\n--- Ação: ${this.nome} curtiu a receita '${receitaAlvo.getTitulo()}' ---`);
        // Chama o gatilho na receita-alvo
        receitaAlvo.adicionarCurtida(this);
    }

    // Ação: Comentar em uma receita
    comentar(receitaAlvo: Receita, comentario: string): void {
        console.log(`\n--- Ação: ${this.nome} comentou na receita '${receitaAlvo.getTitulo()}' ---`);
        // Chama o gatilho" na receita-alvo
        receitaAlvo.adicionarComentario(comentario, this);
    }

    // Ação: Comentar em um Check-In
    comentarCheckIn(checkInAlvo: CheckIn, comentario: string): void {
        console.log(`\n--- Ação: ${this.nome} comentou no Check-In ID: ${checkInAlvo.getIdCheckIn()} ---`);
        // Chama o gatilho no checkIn-alvo
        checkInAlvo.adicionarComentario(comentario, this);
    }

 // Métodos Gatilho

    // Gatilho: Este usuário é seguido por alguém
    serSeguidoPor(novoSeguidor: Usuario): void {
        // 1. Lógica interna ....

        // 2. Chamar o notificar para avisar os observadores
        console.log(`[GATILHO NO USUÁRIO ${this.nome}]: Notificando observadores...`);
        this.notificar(TipoNotificacao.NOVO_SEGUIDOR, `${novoSeguidor.getNome()} começou a seguir você.`);
    }
}
```

#### 3.2.2 Classe Receita
```typescript
class Receita implements Subject {
    private titulo: string;
    private observadores: Observer[] = [];

    constructor(titulo: string) {
        this.titulo = titulo;
    }

    getTitulo(): string {
        return this.titulo;
    }

    adicionarObservador(o: Observer): void {
        if (o !== null && !this.observadores.includes(o)) {
            this.observadores.push(o);
        }
    }

    removerObservador(o: Observer): void {
        const index = this.observadores.indexOf(o);
        if (index > -1) {
            this.observadores.splice(index, 1);
        }
    }

    notificar(tipo: TipoNotificacao, dados: any): void {
        for (const obs of this.observadores) {
            obs.atualizar(tipo, dados);
        }
    }

    // --- Métodos Gatilho ---

    adicionarCurtida(autorDaCurtida: Usuario): void {
        // 1. Lógica interna ....

        // 2. Chamar o notificar para avisar os observadores
        console.log(`[GATILHO NA RECEITA ${this.titulo}]: Notificando observadores...`);
        this.notificar(TipoNotificacao.CURTIDA_RECEITA, `${autorDaCurtida.getNome()} curtiu sua receita.`);
    }

    adicionarComentario(comentario: string, autorDoComentario: Usuario): void {
        // 1. Lógica interna ....

        // 2. Chamar o notificar para avisar os observadores
        console.log(`[GATILHO NA RECEITA ${this.titulo}]: Notificando observadores...`);
        this.notificar(TipoNotificacao.COMENTARIO_RECEITA, `${autorDoComentario.getNome()} comentou: ${comentario}`);
    }
}
```

#### 3.2.3 Classe CheckIn
```typescript
class CheckIn implements Subject {
    private idCheckIn: number;
    private observadores: Observer[] = [];

    constructor(id: number) {
        this.idCheckIn = id;
    }

    getIdCheckIn(): number {
        return this.idCheckIn;
    }

    adicionarObservador(o: Observer): void {
        if (o !== null && !this.observadores.includes(o)) {
            this.observadores.push(o);
        }
    }

    removerObservador(o: Observer): void {
        const index = this.observadores.indexOf(o);
        if (index > -1) {
            this.observadores.splice(index, 1);
        }
    }

    notificar(tipo: TipoNotificacao, dados: any): void {
        for (const obs of this.observadores) {
            obs.atualizar(tipo, dados);
        }
    }

    // --- Método "Gatilho" ---
    adicionarComentario(comentario: string, autorDoComentario: Usuario): void {
        // 1. Lógica interna ....

        // 2. Chamar o notificar para avisar os observadores
        console.log(`[GATILHO NO CHECKIN ${this.idCheckIn}]: Notificando observadores...`);
        this.notificar(TipoNotificacao.COMENTARIO_CHECKIN, `${autorDoComentario.getNome()} comentou no seu Check-In.`);
    }
}

```

#### 3.2.4 Classe Ranking
```typescript
class Ranking implements Subject {
    private IdCompeticao: number;
    private observadores: Observer[] = [];

    constructor(id: number) {
        this.IdCompeticao = id;
    }

    adicionarObservador(o: Observer): void {
        if (o !== null && !this.observadores.includes(o)) {
            this.observadores.push(o);
        }
    }

    removerObservador(o: Observer): void {
        const index = this.observadores.indexOf(o);
        if (index > -1) {
            this.observadores.splice(index, 1);
        }
    }

    notificar(tipo: TipoNotificacao, dados: any): void {
        for (const obs of this.observadores) {
            obs.atualizar(tipo, dados);
        }
    }

    // --- Método "Gatilho" ---
    atualizarRanking(): void {
        // 1. Lógica interna (buscar dados, recalcular)

        // 2. Chamar o notificar!
        console.log(`\n[GATILHO NO RANKING ${this.IdCompeticao}]: Notificando observadores...`);
        this.notificar(TipoNotificacao.ATUALIZACAO_RANKING, `O ranking da competição ${this.IdCompeticao} foi atualizado.`);
    }
}
```

### 3.3 Código Execução
```typescript
function main(): void {
    // --- 1. Criar os objetos concretos ---
    const autorReceita = new Usuario("ChefAna");
    const leitor = new Usuario("LeitorBob");

    const receitaDeBolo = new Receita("Bolo de Chocolate");
    const checkin101 = new CheckIn(101);
    const rankingCompeticao = new Ranking(1);

    // --- 2. Fazer as inscrições (Ligar os fios) ---
    // ChefAna quer ser notificada sobre sua receita
    receitaDeBolo.adicionarObservador(autorReceita);

    // ChefAna quer ser notificada sobre seu check-in
    checkin101.adicionarObservador(autorReceita);

    // ChefAna quer ser notificada sobre o ranking
    rankingCompeticao.adicionarObservador(autorReceita);

    // ChefAna quer ser notificada quando alguém a seguir
    autorReceita.adicionarObservador(autorReceita);

    console.log("--- Fluxo de Notificação Iniciado ---");

    // --- 3. Ações (Disparar os gatilhos) ---

    // Ação 1: Leitor comenta na receita
    leitor.comentar(receitaDeBolo, "Que delícia!");

    // Ação 2: Leitor segue o autor
    leitor.seguir(autorReceita);

    // Ação 3: Leitor curte a receita
    leitor.curtir(receitaDeBolo);

    // Ação 4: Leitor comenta no check-in
    leitor.comentarCheckIn(checkin101, "Ótimo lugar!");

    // Ação 5: O ranking é atualizado
    rankingCompeticao.atualizarRanking();
}

// Executar a função main
main();
```

## 4. Dependências

Para rodar:

- **Node.js** (que inclui o npm)
- **TypeScript**
- **ts-node** (para executar o TypeScript diretamente)


## 5. Como Rodar
```ts
npx ts-node observer.ts
```

## 6. Tabela de Participação do Projeto

| Integrante            | Contribuições Principais                                                                                                                                                                      |
| --------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **Gabriel Soares**    | Estruturação do arquivo, criação e formatação do documento em Markdown, elaboração e desenvolvimento do padrão comportamental Observer, ajustes de estilo e revisão final de todo o conteúdo. |
| **Felipe Bressaneli** | Contribuiu no desenvolvimento  e revisão do padrão e na criação do diagramas UML correspondente                                                                                               |
| **Eduardo Ferreira**  | Contribuiu no desenvolvimento e revisão do padrão e na criação do diagramas UML correspondente                                                                                                |


## 7. Histórico de Versão


| Versão | Data       | Alteração            | Responsável                   | Revisor | Data de revisão |
| ------ | ---------- | -------------------- | ----------------------------- | ------- | --------------- |
| 1.0    | 22/10/2025 | Criação do documento | [Gabriel](github.com/SAnjos3) |         | 23/10/2025      |