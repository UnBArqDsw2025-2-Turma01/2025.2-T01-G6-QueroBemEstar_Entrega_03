# Padrão Adapter — Projeto Quero Bem Estar

## Introdução

O padrão de projeto **Adapter** é utilizado para permitir que classes com interfaces incompatíveis possam trabalhar juntas, atuando como um tradutor entre elas. Ele adapta a interface de uma classe existente para outra interface esperada pelo sistema, sem a necessidade de modificar o código original. Isso garante flexibilidade, reuso de código e um design mais desacoplado.

No contexto do sistema **Quero Bem Estar**, o Adapter é aplicado para unificar diferentes tipos de publicações feitas pelos usuários — como receitas, postagens e eventos — em uma interface única. Assim, o sistema pode tratar todas essas interações de maneira padronizada, facilitando o gerenciamento e a exibição de conteúdos compartilhados na plataforma.

Essa abordagem é especialmente útil no **Quero Bem Estar**, que é uma plataforma colaborativa voltada à promoção de hábitos alimentares saudáveis. Nela, as pessoas compartilham suas experiências culinárias, dicas de alimentação e eventos relacionados à saúde e bem-estar. Ao empregar o Adapter, garantimos que o sistema consiga lidar de forma uniforme com todos esses tipos de publicações, sem necessidade de código repetido ou de condicionais espalhadas.

---

## Metodologia

O desenvolvimento do Adapter iniciou com a análise das entidades relacionadas às interações do usuário dentro da plataforma — **Receita**, **Postagem** e **Evento**. Cada uma possui atributos e comportamentos distintos, mas todas representam uma forma de compartilhamento de informação.

A partir disso, foi criada uma **interface abstrata** definindo os métodos essenciais (como `criar`, `editar` e `curtir`) que todas as entidades devem seguir. Em seguida, foi implementado o **Adapter unificado**, responsável por orquestrar o comportamento específico de cada tipo de publicação, mantendo uma camada de abstração entre a lógica de negócio e as implementações concretas.

Essa arquitetura assegura baixo acoplamento e alta coesão, permitindo a fácil inclusão de novos tipos de publicações no futuro, sem comprometer as funcionalidades existentes.

---

## Modelagem

A modelagem baseia-se em uma estrutura orientada a objetos, onde as classes concretas **Receita**, **Postagem** e **Evento** herdam características comuns e são manipuladas de maneira uniforme pelo Adapter. Esse design favorece a extensibilidade e a clareza arquitetural.

O Adapter atua como intermediário entre o sistema principal e as entidades específicas, tornando possível aplicar operações genéricas — como criação, edição e curtidas — sem que o sistema precise conhecer a implementação detalhada de cada tipo de publicação.

<center>
<p style="text-align: center"><b>Figura 1:</b> Diagrama UML para o Adapter utilizado no projeto Quero Bem Estar.</p>

![Diagrama Adapter](../assets/ImgAdapter/Adapter.jpg)

<font size="3"><p style="text-align: center"><b>Autores:</b> Equipe Quero Bem Estar, 2025</p></font>
</center>

---

## Código

### Entidades de Publicação (`adapter.py`)

```python
class Receita:
    def __init__(self, nome, ingredientes, criador, calorias):
        self.nome = nome
        self.ingredientes = ingredientes
        self.criador = criador
        self.calorias = calorias

class Postagem:
    def __init__(self, titulo, conteudo, autor):
        self.titulo = titulo
        self.conteudo = conteudo
        self.autor = autor

class Evento:
    def __init__(self, nome, local, data, organizador):
        self.nome = nome
        self.local = local
        self.data = data
        self.organizador = organizador
```

---

### Interface do Adapter (`adapter.py`)

```python
from abc import ABC, abstractmethod

class PublicacaoAdapterInterface(ABC):
    @abstractmethod
    def criar(self):
        pass

    @abstractmethod
    def editar(self, novo_conteudo):
        pass

    @abstractmethod
    def curtir(self):
        pass
```

---

### Implementação do Adapter Unificado (`adapter.py`)

```python
class PublicacaoAdapter(PublicacaoAdapterInterface):
    def __init__(self, receita=None, postagem=None, evento=None):
        self.receita = receita
        self.postagem = postagem
        self.evento = evento
        self.curtidas = 0

    def criar(self):
        if self.receita:
            return f"Receita criada: {self.receita.nome} por {self.receita.criador}"
        elif self.postagem:
            return f"Postagem criada: {self.postagem.titulo} por {self.postagem.autor}"
        elif self.evento:
            return f"Evento criado: {self.evento.nome} em {self.evento.local}"
        else:
            raise ValueError("Nenhuma publicação fornecida.")

    def editar(self, novo_conteudo):
        print(f"Publicação editada: {novo_conteudo}")

    def curtir(self):
        self.curtidas += 1
        print(f"Publicação curtida! Total: {self.curtidas}")
```

---

### Gerenciador e Teste (`teste_adapter.py`)

```python
from adapter import Receita, Postagem, Evento, PublicacaoAdapter

class PublicacaoManager:
    def __init__(self):
        self.publicacoes = []

    def criar_publicacao(self, adapter):
        p = adapter.criar()
        self.publicacoes.append(p)
        print(p)

    def editar_publicacao(self, adapter, conteudo):
        adapter.editar(conteudo)

    def curtir_publicacao(self, adapter):
        adapter.curtir()

    def exibir_publicacoes(self):
        print("\n--- Publicações ---")
        for idx, p in enumerate(self.publicacoes):
            print(f"{idx+1}. {p}")

if __name__ == "__main__":
    manager = PublicacaoManager()

    receita = Receita("Smoothie Verde", ["Espinafre", "Banana", "Maçã"], "Ana", 150)
    postagem = Postagem("Benefícios da aveia", "A aveia ajuda na digestão...", "Carlos")
    evento = Evento("Feira Saudável", "Praça Central", "2025-11-15", "Lucas")

    adapter_receita = PublicacaoAdapter(receita=receita)
    adapter_postagem = PublicacaoAdapter(postagem=postagem)
    adapter_evento = PublicacaoAdapter(evento=evento)

    manager.criar_publicacao(adapter_receita)
    manager.criar_publicacao(adapter_postagem)
    manager.criar_publicacao(adapter_evento)

    manager.curtir_publicacao(adapter_receita)
    manager.editar_publicacao(adapter_postagem, "Novo conteúdo sobre aveia!")
    manager.exibir_publicacoes()
```

---

## Validação

A implementação foi testada para garantir que diferentes tipos de publicações (receitas, postagens e eventos) possam ser tratados de maneira uniforme. O Adapter permite criar, editar e curtir qualquer tipo de publicação sem que o sistema precise conhecer sua estrutura interna.

Esse comportamento foi validado por meio de execuções simples, nas quais o mesmo gerenciador foi capaz de lidar com instâncias de diferentes tipos de objetos de forma transparente. Assim, o padrão Adapter promoveu um design mais limpo, flexível e escalável.

---

## Conclusão

A aplicação do **padrão Adapter** no **Quero Bem Estar** proporcionou uma forma eficiente de integrar diferentes tipos de publicações dentro de uma mesma interface. O resultado é uma arquitetura mais organizada, fácil de manter e expandir, refletindo diretamente na experiência dos usuários, que podem compartilhar suas receitas, eventos e postagens de forma unificada e intuitiva.

Essa solução reforça os princípios de **baixo acoplamento** e **alta coesão**, garantindo que futuras evoluções da plataforma — como a inclusão de novos tipos de conteúdo — possam ser feitas sem grandes refatorações, mantendo a consistência e a escalabilidade do sistema.

| Nome | Matrícula | GitHub |
|------|------------|--------|
| Marco Marques de Castro | *211062197* | [@marcomarquesdc](https://github.com/marcomarquesdc) |
