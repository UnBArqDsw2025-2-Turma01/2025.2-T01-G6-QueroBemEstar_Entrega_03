# Padrão Adapter — Projeto Quero Bem Estar

## Introdução

O padrão de projeto **Adapter** é utilizado para permitir que classes com interfaces incompatíveis possam trabalhar juntas, atuando como um tradutor entre elas. Ele adapta a interface de uma classe existente para outra interface esperada pelo sistema, sem a necessidade de modificar o código original. Isso garante flexibilidade, reuso de código e um design mais desacoplado.

No contexto do sistema **Quero Bem Estar**, o Adapter foi aplicado em algumas frentes principais:

1. **Publicações**: Unifica diferentes tipos de publicações feitas pelos usuários — como receitas, postagens e eventos — em uma interface única.
2. **Notificações**: Integra diferentes serviços de notificação (E-mail e Push) através de uma interface padronizada.

Essas abordagens são especialmente úteis no **Quero Bem Estar**, que é uma plataforma colaborativa voltada à promoção de hábitos alimentares saudáveis. Nela, as pessoas compartilham suas experiências culinárias, dicas de alimentação e eventos relacionados à saúde e bem-estar, além de receberem notificações sobre atividades relevantes na plataforma.

---

## Metodologia

O desenvolvimento dos Adapters iniciou com a análise das necessidades do sistema:

### Adapter de Publicações

Foi analisado as entidades relacionadas às interações do usuário dentro da plataforma — **Receita**, **Postagem** e **Evento**. Cada uma possui atributos e comportamentos distintos, mas todas representam uma forma de compartilhamento de informação.

A partir disso, foi criada uma **interface abstrata** definindo os métodos essenciais (como `criar`, `editar` e `curtir`) que todas as entidades devem seguir. Em seguida, foi implementado o **Adapter unificado**, responsável por orquestrar o comportamento específico de cada tipo de publicação.

### Adapter de Notificações

Foi identificada a necessidade de integrar diferentes serviços de notificação (**E-mail** e **Push**) que possuem estruturas de dados distintas. O serviço de e-mail trabalha com destinatário, assunto e corpo da mensagem, enquanto o serviço push utiliza ID de usuário, título e mensagem.

Foi então criada uma **interface INotification** com métodos padronizados (`enviar`, `agendar` e `cancelar`), e implementado o **NotificationAdapter** que converte os diferentes formatos de dados para essa interface unificada.

Essa arquitetura assegura baixo acoplamento e alta coesão, permitindo a fácil inclusão de novos tipos de publicações e serviços de notificação no futuro, sem comprometer as funcionalidades existentes.

---

## Modelagem

A modelagem baseia-se em uma estrutura orientada a objetos, onde as classes concretas são manipuladas de maneira uniforme pelos Adapters. Esse design favorece a extensibilidade e a clareza arquitetural.

### Adapter de Publicações

As classes concretas **Receita**, **Postagem** e **Evento** herdam características comuns e são manipuladas pelo **PublicacaoAdapter**. Esse design permite aplicar operações genéricas — como criação, edição e curtidas — sem que o sistema precise conhecer a implementação detalhada de cada tipo de publicação.


<div align="center">
  <img src="../assets/Adpater.png" alt="Diagrama Adapter Publicações" >
</div>

### Adapter de Notificações

As classes **EmailService** e **PushService** representam diferentes formas de envio de notificações. O **NotificationAdapter** atua como intermediário, convertendo as estruturas específicas de cada serviço para a interface unificada **INotification**.

<div align="center">
  <img src="../assets/Adpater2.png" alt="Diagrama Adapter Notificações" >
</div>

---

## Código

## 1. Adapter de Publicações

### Entidades de Publicação (`adapter.py`)

```python
class Receita:
    def __init__(self, nome, ingredientes, criador, calorias):
        self.nome = nome
        self.ingredientes = ingredientes
        self.criador = criador
        self.calorias = calorias

class Postagem:
    def __init__(self, titulo, conteudo, autor):
        self.titulo = titulo
        self.conteudo = conteudo
        self.autor = autor

```

---

### Interface do Adapter (`adapter.py`)

```python
from abc import ABC, abstractmethod

class PublicacaoAdapterInterface(ABC):
    @abstractmethod
    def criar(self):
        pass

    @abstractmethod
    def editar(self, novo_conteudo):
        pass

    @abstractmethod
    def curtir(self):
        pass
```

---

### Implementação do Adapter Unificado (`adapter.py`)

```python
class PublicacaoAdapter(PublicacaoAdapterInterface):
    def __init__(self, receita=None, postagem=None, evento=None):
        self.receita = receita
        self.postagem = postagem
        self.evento = evento
        self.curtidas = 0

    def criar(self):
        if self.receita:
            return f"Receita criada: {self.receita.nome} por {self.receita.criador}"
        elif self.postagem:
            return f"Postagem criada: {self.postagem.titulo} por {self.postagem.autor}"
        else:
            raise ValueError("Nenhuma publicação fornecida.")

    def editar(self, novo_conteudo):
        print(f"Publicação editada: {novo_conteudo}")

    def curtir(self):
        self.curtidas += 1
        print(f"Publicação curtida! Total: {self.curtidas}")
```

---

### Gerenciador e Teste (`teste_adapter.py`)

```python
from adapter import Receita, Postagem, Evento, PublicacaoAdapter

class PublicacaoManager:
    def __init__(self):
        self.publicacoes = []

    def criar_publicacao(self, adapter):
        p = adapter.criar()
        self.publicacoes.append(p)
        print(p)

    def editar_publicacao(self, adapter, conteudo):
        adapter.editar(conteudo)

    def curtir_publicacao(self, adapter):
        adapter.curtir()

    def exibir_publicacoes(self):
        print("\n--- Publicações ---")
        for idx, p in enumerate(self.publicacoes):
            print(f"{idx+1}. {p}")

if __name__ == "__main__":
    manager = PublicacaoManager()

    receita = Receita("Smoothie Verde", ["Espinafre", "Banana", "Maçã"], "Ana", 150)
    postagem = Postagem("Benefícios da aveia", "A aveia ajuda na digestão...", "Carlos")

    adapter_receita = PublicacaoAdapter(receita=receita)
    adapter_postagem = PublicacaoAdapter(postagem=postagem)

    manager.criar_publicacao(adapter_receita)
    manager.criar_publicacao(adapter_postagem)

    manager.curtir_publicacao(adapter_receita)
    manager.editar_publicacao(adapter_postagem, "Novo conteúdo sobre aveia!")
    manager.exibir_publicacoes()
```

---

## 2. Adapter de Notificações

### Serviços de Notificação (`EmailService.ts` e `PushService.ts`)

```typescript
// EmailService.ts
export class EmailService {
	public destinatario: string;
	public assunto: string;
	public corpo: string;

	constructor(destinatario: string, assunto: string, corpo: string) {
		this.destinatario = destinatario;
		this.assunto = assunto;
		this.corpo = corpo;
	}
}

// PushService.ts
export class PushService {
	public idUsuario: string;
	public titulo: string;
	public mensagem: string;

	constructor(idUsuario: string, titulo: string, mensagem: string) {
		this.idUsuario = idUsuario;
		this.titulo = titulo;
		this.mensagem = mensagem;
	}
}
```

---

### Interface do Adapter de Notificações (`INotification.ts`)

```typescript
export interface INotification {
	enviar(): string;
	agendar(data: string): void;
	cancelar(): void;
}
```

---

### Implementação do Adapter de Notificações (`NotificationAdapter.ts`)

```typescript
import { INotification } from "./INotification";
import { EmailService } from "./EmailService";
import { PushService } from "./PushService";

export class NotificationAdapter implements INotification {
	private readonly emailService?: EmailService;
	private readonly pushService?: PushService;
	private agendamento?: string;

	constructor(emailService?: EmailService, pushService?: PushService) {
		this.emailService = emailService;
		this.pushService = pushService;
	}

	enviar(): string {
		if (this.emailService) {
			return `E-mail enviado: ${this.emailService.assunto} para ${this.emailService.destinatario}`;
		} else if (this.pushService) {
			return `Notificação Push enviada: ${this.pushService.titulo} para usuário ${this.pushService.idUsuario}`;
		} else {
			throw new Error("Nenhum serviço de notificação fornecido.");
		}
	}

	agendar(data: string): void {
		this.agendamento = data;
		console.log(`Notificação agendada para: ${data}`);
	}

	cancelar(): void {
		console.log("Notificação cancelada.");
	}
}
```

---

### Gerenciador e Teste (`NotificationSystem.ts`)

```typescript
import { NotificationAdapter } from "./NotificationAdapter";
import { EmailService } from "./EmailService";
import { PushService } from "./PushService";

export class NotificationManager {
	private readonly notificacoes: string[] = [];

	enviarNotificacao(adapter: NotificationAdapter): void {
		const resultado = adapter.enviar();
		this.notificacoes.push(resultado);
		console.log(resultado);
	}

	agendarNotificacao(adapter: NotificationAdapter, data: string): void {
		adapter.agendar(data);
	}

	cancelarNotificacao(adapter: NotificationAdapter): void {
		adapter.cancelar();
	}

	exibirNotificacoes(): void {
		console.log("\n--- Notificações Enviadas ---");
		for (let i = 0; i < this.notificacoes.length; i++) {
			console.log(`${i + 1}. ${this.notificacoes[i]}`);
		}
	}
}

// Teste do Adapter
if (require.main === module) {
	const manager = new NotificationManager();

	const emailService = new EmailService(
		"usuario@gmail.com",
		"Bem-vindo ao Quero Bem Estar!",
		"Obrigado por se cadastrar em nossa plataforma."
	);

	const pushService = new PushService(
		"user_12345",
		"Nova Competição Disponível",
		"Participe da competição de receitas fitness!"
	);

	const adapterEmail = new NotificationAdapter(emailService);
	const adapterPush = new NotificationAdapter(undefined, pushService);

	manager.enviarNotificacao(adapterEmail);
	manager.enviarNotificacao(adapterPush);

	manager.agendarNotificacao(adapterEmail, "2025-11-20 10:00");
	manager.cancelarNotificacao(adapterPush);

	manager.exibirNotificacoes();
}
```

---

## Validação

### Adapter de Publicações

A implementação foi testada para garantir que diferentes tipos de publicações (receitas, postagens e eventos) possam ser tratados de maneira uniforme. O Adapter permite criar, editar e curtir qualquer tipo de publicação sem que o sistema precise conhecer sua estrutura interna.

Esse comportamento foi validado por meio de execuções simples, nas quais o mesmo gerenciador foi capaz de lidar com instâncias de diferentes tipos de objetos de forma transparente.

### Adapter de Notificações

O sistema de notificações foi testado para garantir que serviços diferentes (E-mail e Push) possam ser tratados através da mesma interface. O NotificationManager consegue enviar, agendar e cancelar notificações independentemente do tipo de serviço subjacente.

**Saída de Exemplo:**

```
E-mail enviado: Bem-vindo ao Quero Bem Estar! para usuario@gmail.com
Notificação Push enviada: Nova Competição Disponível para usuário user_12345
Notificação agendada para: 2025-11-20 10:00
Notificação cancelada.

--- Notificações Enviadas ---
1. E-mail enviado: Bem-vindo ao Quero Bem Estar! para usuario@gmail.com
2. Notificação Push enviada: Nova Competição Disponível para usuário user_12345
```

Assim, o padrão Adapter promoveu um design mais limpo, flexível e escalável em ambas as implementações.

---

## Conclusão

A aplicação do **padrão Adapter** no **Quero Bem Estar** proporcionou uma forma eficiente de integrar diferentes tipos de entidades através de interfaces unificadas:

- **Publicações**: Receitas, postagens e eventos podem ser gerenciados de forma uniforme
- **Notificações**: E-mails e notificações push são tratados através da mesma interface

O resultado é uma arquitetura mais organizada, fácil de manter e expandir, refletindo diretamente na experiência dos usuários, que podem compartilhar conteúdos e receber notificações de forma unificada e intuitiva.

Essa solução reforça os princípios de **baixo acoplamento** e **alta coesão**, garantindo que futuras evoluções da plataforma — como a inclusão de novos tipos de conteúdo ou serviços de notificação — possam ser feitas sem grandes refatorações, mantendo a consistência e a escalabilidade do sistema.

---

### Tabela de Participação do Projeto

| Integrante         | Contribuições Principais                                                                 |
|--------------------|------------------------------------------------------------------------------------------|
| **Artur**           | Participou da criação do documento, modelagem do adapter e implementação do padrão.                 |
| **Marcos**          | Participou da criação do documento, modelagem do adapter e implementação do padrão.                 |
| **Mylena**          | Participou da criação do documento, modelagem do adapter e implementação do padrão.                 |
| **Yago**            | Participou da criação do documento, modelagem do adapter e implementação do padrão.                 |

## Histórico de Versão

| Versão | Data | Alteração | Responsável | Revisor | Data de revisão |
| ------ | ---- | --------- | ----------- | ------- | --------------- |
| 1.0    | 23/10/2025 | Criação do documento e Adapter de Publicações. |  [Marco Marques de Castro](https://github.com/marcomarquesdc)  |[Yago Amin](https://github.com/yagoas) | 23/10/2025 |
| 1.1    | 23/10/2025 | Adiciona o Adapter de Notificações. |  [Yago Amin](https://github.com/yagoas)  | | |
