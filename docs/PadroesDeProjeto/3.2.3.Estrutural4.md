# Padr√£o de Projeto: Composite

## Vis√£o Geral

O padr√£o **Composite** √© um padr√£o estrutural que permite compor objetos em estruturas de √°rvore para representar hierarquias do tipo partes-todo. Ele permite que clientes tratem objetos individuais e composi√ß√µes de objetos de maneira uniforme.

No contexto do nosso projeto, o padr√£o Composite √© utilizado na camada de valida√ß√£o para compor m√∫ltiplos validadores em um √∫nico objeto, permitindo a execu√ß√£o sequencial de valida√ß√µes e a reutiliza√ß√£o de validadores em diferentes contextos.

---

## Princ√≠pios e Vantagens

A ado√ß√£o do padr√£o Composite traz diversos benef√≠cios alinhados aos princ√≠pios de bom design de software:

- **Composi√ß√£o sobre Heran√ßa:** Permite criar estruturas complexas atrav√©s da composi√ß√£o de objetos simples.
- **Simplicidade de Uso:** O cliente trabalha com a mesma interface, independentemente de lidar com objetos simples ou compostos.
- **Flexibilidade:** F√°cil adicionar novos validadores ou componentes sem modificar o c√≥digo existente.
- **Reutiliza√ß√£o:** Validadores individuais podem ser reutilizados em diferentes composi√ß√µes.
- **Separa√ß√£o de Responsabilidades:** Cada validador tem uma √∫nica responsabilidade e pode ser testado isoladamente.
- **Extensibilidade:** A estrutura permite f√°cil extens√£o com novos validadores sem afetar componentes existentes.

---

## Casos de Uso

√â crucial saber quando aplicar (e quando n√£o aplicar) o padr√£o.

##### ‚úÖ Quando usar Composite?

- Quando voc√™ precisa representar hierarquias partes-todo em estruturas de √°rvore.
- Quando m√∫ltiplos componentes precisam ser executados em sequ√™ncia com a mesma interface.
- Quando voc√™ deseja permitir que clientes tratem composi√ß√µes de objetos da mesma forma que objetos individuais.
- Em sistemas de valida√ß√£o que precisam compor m√∫ltiplos validadores.
- Em sistemas de processamento de dados com m√∫ltiplas etapas independentes.
- Quando a estrutura do problema naturalmente se mapeia para uma estrutura em √°rvore.

##### üö´ Quando N√ÉO usar?

- Quando a hierarquia √© muito simples e apenas dois n√≠veis (folha e composi√ß√£o).
- Quando o desempenho √© cr√≠tico e a recurs√£o em profundidade afeta negativamente o sistema.
- Quando a l√≥gica de cada componente √© muito diferente, tornando a abstra√ß√£o comum artificial.

---

## Modelagem no Projeto (Diagrama UML)

O diagrama abaixo ilustra a estrutura do padr√£o Composite em nosso projeto.

![Diagrama UML Composite](../assets/Composite.drawio.png)

O diagrama UML define a estrutura do padr√£o Composite com os seguintes componentes:

- **Component (Interface)**: Define a interface comum para objetos simples e compostos.

  - `+ validate(input: any): Error | null`

- **Leaf (Validador Simples)**: Implementa a interface Component para objetos simples.

  - `RequiredFieldValidation`
  - `NumberValidation`

- **Composite (Validador Composto)**: Implementa a interface Component e cont√©m uma cole√ß√£o de Components.
  - `ValidationComposite`
  - `- validations: Validation[]` (cole√ß√£o de validadores)
  - `+ validate(input: any): Error | null` (executa todos os validadores)

---

## Implementa√ß√£o do Padr√£o Composite

O padr√£o Composite √© implementado atrav√©s de uma interface comum (`Validation`) que √© implementada tanto por validadores simples (Leafs) quanto pelo validador composto (Composite). Abaixo apresentamos os componentes principais:

### Passo 1: A Interface Component (Validation)

A interface define o contrato que todos os validadores devem seguir, tanto os simples quanto os compostos.

```typescript
export interface Validation {
  validate: (input: any) => Error | null
}
```

Esta interface √© m√≠nima e clara: todos os validadores devem implementar um m√©todo `validate` que recebe uma entrada e retorna um `Error` se a valida√ß√£o falhar, ou `null` se passar.

### Passo 2: Os Leafs (Validadores Simples)

Os validadores simples implementam a interface `Validation` e executam uma valida√ß√£o espec√≠fica:

#### RequiredFieldValidation.ts

```typescript
import { MissingParamError } from '@/presentation/errors/missing-param-error';
import { Validation } from '@/presentation/protocols/validation';

export class RequiredFieldValidation implements Validation {
  constructor(private readonly fieldName: string) {}

  validate(input: any): Error | null {
    if (!input[this.fieldName]) {
      return new MissingParamError(`${String(this.fieldName)}`);
    }
    return null;
  }
}
```

Este √© um validador simples que verifica se um campo obrigat√≥rio est√° presente.

#### NumberValidation.ts

```typescript
import { InvalidParamError } from '@/presentation/errors/invalid-param-error';
import { Validation } from '@/presentation/protocols/validation';

export class NumberValidation implements Validation {
  constructor(private readonly fieldName: string) {}

  validate(input: any): Error | null {
    if (isNaN(input[this.fieldName])) {
      return new InvalidParamError(`${String(this.fieldName)}`);
    }
    return null;
  }
}
```

Este √© outro validador simples que verifica se um campo cont√©m um n√∫mero v√°lido.

### Passo 3: O Composite (Validador Composto)

O `ValidationComposite` √© o cora√ß√£o do padr√£o. Ele implementa a mesma interface `Validation` mas, em vez de executar uma valida√ß√£o simples, executa uma sequ√™ncia de validadores:

```typescript
import { Validation } from '@/presentation/protocols/validation';

export class ValidationComposite implements Validation {
  constructor(private readonly validations: Validation[]) {}

  validate(input: any): Error | null {
    for (const validation of this.validations) {
      const error = validation.validate(input);
      if (error) {
        return error;
      }
    }
    return null;
  }
}
```

**Caracter√≠sticas Principais:**

- Recebe uma cole√ß√£o de validadores no construtor
- Implementa a mesma interface que os validadores simples
- Itera sobre todos os validadores compostos
- Retorna o primeiro erro encontrado (valida√ß√£o fail-fast)
- Retorna `null` se todos os validadores passarem

### Passo 4: Factory Pattern (Composi√ß√£o de Validadores)

Para facilitar a cria√ß√£o de validadores compostos com os validadores simples adequados, utilizamos um Factory:

```typescript
import { Validation } from '@/presentation/protocols/validation';
import { NumberValidation } from '@/validation/validators/number-validation';
import { RequiredFieldValidation } from '@/validation/validators/required-field-validation';
import { ValidationComposite } from '@/validation/validators/validation-composite';

export const makeCreateCompetitionValidation = (): ValidationComposite => {
  const validations: Validation[] = [];
  for (const field of ['name', 'durationInDays']) {
    validations.push(new RequiredFieldValidation(field));
  }
  validations.push(new NumberValidation('durationInDays'));
  return new ValidationComposite(validations);
};
```

**Fluxo de Execu√ß√£o:**

1. O factory cria uma array de validadores
2. Adiciona `RequiredFieldValidation` para os campos "name" e "durationInDays"
3. Adiciona `NumberValidation` para o campo "durationInDays"
4. Retorna um `ValidationComposite` contendo todos esses validadores
5. Quando `validate` √© chamado no composite, todos os validadores s√£o executados em sequ√™ncia

### Passo 5: Uso no Controller

O controller recebe o validador composto e o utiliza como se fosse um validador simples:

```typescript
export class CreateCompetitionController implements IController {
  constructor(
    private readonly validation: Validation,
    private readonly createCompetition: ICreateCompetitionUseCase,
  ) {}

  async handle(
    request: HttpRequest<CreateCompetitionRequest>,
  ): Promise<HttpResponse> {
    const temporaryOwnerId = 1

    if (!request.body) {
      return badRequest(new MissingParamError("body"))
    }

    const error = this.validation.validate(request.body)
    if (error) {
      return badRequest(error)
    }

    const { name, durationInDays, description } =
      request.body as CreateCompetitionRequest

    const competition = await this.createCompetition.create({
      ownerId: temporaryOwnerId,
      name,
      durationInDays: Number(durationInDays),
      description,
    })

    return {
      statusCode: 200,
      body: competition,
    }
  }
}
```

O controller n√£o precisa saber que est√° lidando com um composite. Para ele, √© apenas um validador que implementa a interface `Validation`.

---

## Benef√≠cios Pr√°ticos no Projeto

1. **Reutiliza√ß√£o**: Cada validador simples pode ser reutilizado em diferentes composi√ß√µes
2. **Extensibilidade**: Novos validadores podem ser criados sem modificar c√≥digo existente
3. **Testabilidade**: Cada validador simples pode ser testado isoladamente
4. **Simplicidade**: O cliente usa a mesma interface para validadores simples e compostos
5. **Flexibilidade**: Diferentes combina√ß√µes de validadores podem ser criadas facilmente

---

## Para Mais Detalhes e Execu√ß√£o

Para informa√ß√µes completas sobre a implementa√ß√£o do padr√£o Composite, consultar o arquivo `README.md` na pasta do [monolito](https://github.com/UnBArqDsw2025-2-Turma01/2025.2-T01-G6-QueroBemEstar_Entrega_03/tree/main/monolito) do reposit√≥rio. L√° voc√™ encontrar√° documenta√ß√£o detalhada sobre a estrutura de pastas, configura√ß√µes e como executar a aplica√ß√£o.

- `monolito/src/validation/validators/validation-composite.ts` - Implementa√ß√£o do Composite
- `monolito/src/main/factories/controllers/create-competition-validation-factory.ts` - Factory de valida√ß√£o

---

## Hist√≥rico de Vers√£o

| Vers√£o | Data       | Altera√ß√£o                             | Respons√°vel       | Revisor | Data de revis√£o |
| ------ | ---------- | ------------------------------------- | ----------------- | ------- | --------------- |
| 1.0    | 23/10/2025 | Cria√ß√£o do documento sobre Composite. | Artur Krauspenhar |         |                 |
