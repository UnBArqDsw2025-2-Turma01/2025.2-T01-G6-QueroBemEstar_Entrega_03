# 3. Desenho de Software (Padrões de Projeto)

Nesta etapa do projeto, o grupo estudou e implementou diversos **Padrões de Projeto GoFs**, divididos nas três categorias principais: **Criacionais**, **Estruturais** e **Comportamentais**.  
Esses padrões foram aplicados com o objetivo de melhorar a organização do código, promover o reuso e facilitar a manutenção e evolução do sistema.

---

## 3.1. Padrões de Projeto GoFs Criacionais

Os padrões criacionais tratam da **forma como objetos são criados**, buscando tornar o sistema independente de como seus objetos são instanciados, compostos e representados.

### 3.1.1. Singleton
O padrão **Singleton** garante que uma classe tenha **apenas uma instância** e fornece um ponto global de acesso a ela.  
Foi utilizado para centralizar informações compartilhadas no sistema e evitar múltiplas instâncias desnecessárias.

### 3.1.2. Factory
O padrão **Factory Method** define uma **interface para criar objetos**, mas permite que as subclasses decidam qual classe instanciar.  
Essa abordagem promove o desacoplamento entre o código cliente e as classes concretas que são criadas.

### 3.1.3. Builder
O padrão **Builder** separa a **construção de um objeto complexo** da sua representação, permitindo que o mesmo processo de construção crie diferentes representações.  
Foi útil para organizar a criação de objetos com muitos parâmetros opcionais ou etapas de inicialização.

---

## 3.2. Padrões de Projeto GoFs Estruturais

Os padrões estruturais tratam da **composição de classes e objetos**, facilitando a construção de estruturas flexíveis e reutilizáveis.

### 3.2.1. Proxy
O padrão **Proxy** fornece um **substituto ou representante** para outro objeto, controlando o acesso a ele.  
Foi aplicado para intermediar operações e controlar quando certos recursos seriam realmente carregados ou executados.

### 3.2.2. Adapter
O padrão **Adapter** converte a **interface de uma classe em outra interface esperada pelos clientes**, permitindo que classes com interfaces incompatíveis trabalhem juntas.  
Facilitou a integração de componentes que não foram originalmente projetados para interagir.

### 3.2.3. Composite
O padrão **Composite** permite compor objetos em **estruturas hierárquicas de árvore**, tratando objetos individuais e composições de forma uniforme.  
Foi útil na representação de estruturas complexas onde elementos podiam conter outros elementos.

### 3.2.4. Decorator
O padrão **Decorator** permite **adicionar responsabilidades dinamicamente** a um objeto, sem alterar sua estrutura original.  
Isso trouxe maior flexibilidade ao estender funcionalidades de objetos de maneira não intrusiva.

---

## 3.3. Padrões de Projeto GoFs Comportamentais

Os padrões comportamentais se concentram na **interação e comunicação entre objetos**, definindo como responsabilidades são distribuídas.

### 3.3.1. Strategy
O padrão **Strategy** define uma **família de algoritmos**, encapsula cada um e os torna intercambiáveis.  
Foi usado para permitir que diferentes estratégias pudessem ser aplicadas dinamicamente sem alterar o código cliente.

### 3.3.2. Observer
O padrão **Observer** estabelece uma **dependência um-para-muitos** entre objetos, de modo que quando um objeto muda de estado, todos os seus dependentes são notificados automaticamente.  
Facilitou a atualização automática de componentes interdependentes no sistema.

### 3.3.3. Mediator
O padrão **Mediator** centraliza a **comunicação entre objetos**, evitando que eles se refiram diretamente uns aos outros.  
Isso reduziu o acoplamento e tornou as interações mais fáceis de gerenciar e estender.

---

## Conclusão

A aplicação dos **Padrões de Projeto GoFs** foi fundamental para aprimorar a arquitetura do sistema desenvolvido.  
Cada padrão contribuiu para resolver problemas específicos de acoplamento, flexibilidade e reutilização, resultando em um código mais limpo, modular e de fácil manutenção.
