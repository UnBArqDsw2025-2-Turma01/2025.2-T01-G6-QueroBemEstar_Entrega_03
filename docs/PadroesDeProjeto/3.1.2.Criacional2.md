# PadrÃ£o de Projeto: Builder

## VisÃ£o Geral

Este documento descreve a implementaÃ§Ã£o do padrÃ£o de projeto Builder em nosso sistema. O Builder Ã© um padrÃ£o criacional focado em separar a construÃ§Ã£o de um objeto complexo da sua representaÃ§Ã£o final.

**IntenÃ§Ã£o**: Utilizamos o Builder para simplificar a criaÃ§Ã£o de objetos que possuem muitos atributos, configuraÃ§Ãµes opcionais ou um processo de inicializaÃ§Ã£o que exige vÃ¡rios passos. Isso torna o cÃ³digo de instanciaÃ§Ã£o mais legÃ­vel, manutenÃ­vel e menos propenso a erros.

---

## PrincÃ­pios e Vantagens

A adoÃ§Ã£o do padrÃ£o Builder traz diversos benefÃ­cios alinhados aos princÃ­pios de bom design de software:

- **Responsabilidade Ãºnica (SRP)**: A lÃ³gica de construÃ§Ã£o fica separada da lÃ³gica de negÃ³cio do objeto que estÃ¡ sendo construÃ­do.
- **Facilidade de Leitura e ManutenÃ§Ã£o:** O cÃ³digo de criaÃ§Ã£o do objeto torna-se mais claro e verboso.
- **RepresentaÃ§Ãµes Diferentes:** Permite que o mesmo processo de construÃ§Ã£o crie diferentes configuraÃ§Ãµes do objeto final.
- **ReduÃ§Ã£o de Erros:** Evita construtores com longas listas de parÃ¢metros (telescÃ³picos) e reduz o risco de objetos serem criados em estado inconsistente ou parcial.
- **Escalabilidade:** Facilita a adiÃ§Ã£o de novos atributos ao objeto sem quebrar o cÃ³digo cliente existente.

---

## Casos de Uso

Ã‰ crucial saber quando aplicar (e quando nÃ£o aplicar) o padrÃ£o.

##### âœ… Quando usar Builder?

- Quando a criaÃ§Ã£o de objetos envolve muitos passos ou uma lÃ³gica sequencial.
- Quando os objetos a serem criados possuem muitos valores opcionais ou padrÃ£o.
- Quando vocÃª quer manter o construtor da classe principal limpo e enxuto.
- Quando o mesmo processo de construÃ§Ã£o precisa resultar em diferentes representaÃ§Ãµes do objeto. (Ex: Um `Usuario` admin vs. um `Usuario` comum).

##### ðŸš« Quando NÃƒO usar?

- Para objetos simples, com poucos atributos e uma construÃ§Ã£o direta.
- Quando todos os dados do objeto estÃ£o disponÃ­veis de uma sÃ³ vez e a inicializaÃ§Ã£o pode ser feita diretamente em um construtor simples.

---

## Modelagem no Projeto (Diagrama UML)

O diagrama abaixo ilustra a estrutura do padrÃ£o em nosso projeto, cobrindo as entidades `Receita`, `Usuario` e `Competicao`.

![Diagrama UML do Builder](../assets/Builder.svg)

O diagrama UML define a estrutura do padrÃ£o Builder para as entidades `Receita`, `Usuario` e `Competicao`.

- **Interface:** `Builder`
    - `reset()`
    - `get_result(): Any`

- **Director:** `Diretor`
    - Controla o processo de construÃ§Ã£o.
    - `set_builder()`
    - `build_receita()`
    - `build_competicao()`
    - `build_usuario()`

- **Concrete Builders:**
    - `ReceitaBuilder` : ConstrÃ³i um objeto `Receita`.
    - `UsuarioBuilder` : ConstrÃ³i um objeto `Usuario`.
    - `CompeticaoBuilder` : ConstrÃ³i um objeto `Competicao`.

- **Products (Produtos):**
    - `Receita`: O objeto complexo "Receita".
    - `Usuario`: O objeto complexo "UsuÃ¡rio".
    - `Competicao`: O objeto complexo "CompetiÃ§Ã£o".

---

## Estruturas de Builder Aplicadas

Adotamos duas variaÃ§Ãµes principais do padrÃ£o Builder para equilibrar flexibilidade e legibilidade.

#### 1. Estrutura PadrÃ£o: O Builder Fluente

Esta Ã© a nossa abordagem principal, usada para `Usuario` e `Receita`. Ela dispensa um `Diretor` e foca em um "encadeamento" de mÃ©todos (*method chaining*) para uma API limpa.

- **Conceito**: O Builder possui mÃ©todos set_, com_ ou add_ que, em vez de void, retornam self (a prÃ³pria instÃ¢ncia do builder).

- **Vantagem**: CÃ³digo de criaÃ§Ã£o limpo, explÃ­cito e altamente legÃ­vel.

##### Exemplo de CÃ³digo: `UsuarioBuilder`

**Passo 1:** O Produto (`Usuario`) A classe `Usuario` possui um construtor "cheio" que o Builder usarÃ¡ internamente.

```
export class Usuario {
Â  private _id: number;
Â  private _nomeDeUsuario: string;
Â  private _nome: string;
  private _sobrenome: string;
  private _email: string;
  private _senha: string;
  private _fotoPerfilUrl: string | null;
  private _biografia: string | null;
  private _dataCadastro: Date;
  private _googleId: string | null;
  private _emailConfirmado: boolean;
Â  private _seguidores: Usuario[];
  private _seguindo: Usuario[];
  private _receitasSalvas: Receita[];
Â  private _receitasPostadas: Receita[];

Â  constructor(props: UsuarioProps) {
Â  Â  this._id = props.id;
Â  Â  this._nomeDeUsuario = props.nomeDeUsuario;
Â  Â  this._nome = props.nome;
    this._sobrenome = props.sobrenome;
    this._email = props.email;
    this._senha = props.senha;
    this._fotoPerfilUrl = props.fotoPerfilUrl;
    this._biografia = props.biografia;
    this._dataCadastro = props.dataCadastro;
    this._googleId = props.googleId;
    this._emailConfirmado = props.emailConfirmado;
Â  Â  this._seguidores = props.seguidores;
    this._seguindo = props.seguindo;
    this._receitasSalvas = props.receitasSalvas;
Â  Â  this._receitasPostadas = props.receitasPostadas;
Â  }

Â  get id(): number { return this._id; }
Â  get nomeDeUsuario(): string { return this._nomeDeUsuario; }
Â  get nome(): string { return this._nome; }
Â  get seguidores(): Usuario[] { return [...this._seguidores]; }

Â  public seguirUsuario(usuarioAlvo: Usuario): void {
Â  Â  if (!this._seguindo.includes(usuarioAlvo)) {
Â  Â  Â  this._seguindo.push(usuarioAlvo);
Â  Â  Â  usuarioAlvo._seguidores.push(this); 
Â  Â  }
Â  }

Â  public publicarReceita(receitaAlvo: Receita): void {
Â  Â  if (!this._receitasPostadas.includes(receitaAlvo)) {
Â  Â  Â  this._receitasPostadas.push(receitaAlvo);
Â  Â  }
Â  }
}
```

**Passo 2:** O Builder Fluente (UsuarioBuilder.ts) O Builder armazena as props e retorna this para encadeamento . O getResult constrÃ³i o objeto final.

```
export class UsuarioBuilder implements Builder<Usuario> {
Â  private props: Partial<UsuarioProps>;

Â  constructor() {
Â  Â  this.props = this.getDefaultProps();
Â  }

Â  private getDefaultProps(): Partial<UsuarioProps> {
Â  Â  return {
Â  Â  Â  id: 0,
Â  Â  Â  nomeDeUsuario: "",
Â  Â  Â  nome: "",
Â  Â  Â  email: "",
Â  Â  Â  senha: "",
Â  Â  Â  dataCadastro: new Date(),
Â  Â  Â  emailConfirmado: false,
Â  Â  Â  seguidores: [],
Â  Â  Â  seguindo: [],
Â  Â  Â  receitasSalvas: [],
Â  Â  Â  receitasPostadas: [],
Â  Â  };
Â  }

Â  reset(): void {
Â  Â  this.props = this.getDefaultProps();
Â  }

Â  setNomeDeUsuario(nome: string): this {
Â  Â  this.props.nomeDeUsuario = nome;
Â  Â  return this;
Â  }

Â  setNome(nome: string): this {
Â  Â  this.props.nome = nome;
Â  Â  return this;
Â  }

Â  setEmail(email: string): this {
Â  Â  this.props.email = email;
Â  Â  return this;
Â  }

Â  setSenha(senha: string): this {
Â  Â  this.props.senha = senha; 
Â  Â  return this;
Â  }
Â  
  // outros sets

Â  setGoogleId(id: string): this {
Â  Â  this.props.googleId = id;
Â  Â  this.props.emailConfirmado = true;
Â  Â  return this;
Â  }

Â  getResult(): Usuario {
Â  Â  if (!this.props.email || !this.props.nomeDeUsuario) {
Â  Â  Â  throw new Error("Email e Nome de UsuÃ¡rio sÃ£o obrigatÃ³rios.");
Â  Â  }
Â  Â  
Â  Â  const result = new Usuario(this.props as UsuarioProps);
Â  Â  this.reset(); 
Â  Â  return result;
Â  }
}
```

**Passo 3:** O Uso (Legibilidade MÃ¡xima) A criaÃ§Ã£o do objeto se torna declarativa:

```
const builder = new UsuarioBuilder();

const usuarioComum = builder
Â  .setNomeDeUsuario("j_silva")
Â  .setEmail("j@email.com")
Â  .setSenha("senha123")
Â  .setNome("JoÃ£o")
Â  .setSobrenome("Silva")
Â  .getResult();

const usuarioGoogle = builder
Â  .setNomeDeUsuario("ana.g")
Â  .setEmail("ana@google.com")
Â  .setGoogleId("g_12345")
Â  .setNome("Ana")
Â  .setSobrenome("Gomes")
Â  .getResult();
```

#### 2. Estrutura com Diretor (Para "Presets" de CompetiÃ§Ã£o)

Para `Competicao`, usamos o `Diretor`. Esta classe centraliza a lÃ³gica de criaÃ§Ã£o para "tipos" de competiÃ§Ã£o prÃ©-definidos (Ex: "Desafio RÃ¡pido", "Maratona Mensal").

- **Conceito:** O Diretor Ã© stateless (sem estado). Ele nÃ£o armazena o builder. Em vez disso, ele recebe um builder como parÃ¢metro e opera sobre ele para construir uma configuraÃ§Ã£o especÃ­fica.
- **Vantagem:** Centraliza regras de negÃ³cio complexas de criaÃ§Ã£o.

##### Exemplo de CÃ³digo: Diretor

**Passo 1:** O `CompeticaoBuilder` (Fluente) (O `CompeticaoBuilder.ts` segue o mesmo padrÃ£o encapsulado do `UsuarioBuilder.ts`, armazenando `Partial<CompeticaoProps>` e chamando `new Competicao(props)` no `getResult`.)

**Passo 2:** O `Diretor.ts` (Corrigido e Stateless) O `Diretor` nÃ£o precisa mais de `setBuilder` ou de checagens de `instanceof`. Ele Ã© simples e direto.

```
export class Director {
Â  
Â  public buildReceita(builder: ReceitaBuilder): void {
Â  Â  builder.reset();
Â  Â  builder
Â  Â  Â  .setTitulo("Receita PadrÃ£o (do Diretor)")
Â  Â  Â  .setIngredientes(["Ingrediente 1", "Ingrediente 2"])
Â  Â  Â  .setModoPreparo("Modo de preparo padrÃ£o.");
Â  }

Â  public buildCompeticao(builder: CompeticaoBuilder): void {
Â  Â  builder.reset();
Â  Â  builder
Â  Â  Â  .setNome("CompetiÃ§Ã£o PadrÃ£o (do Diretor)")
Â  Â  Â  .setDataInicio(new Date())
Â  Â  Â  .setDuracao(7)
Â  Â  Â  .setLimiteCheckIn(1);
Â  }

Â  public buildUsuario(builder: UsuarioBuilder): void {
Â  Â  builder.reset();
Â  Â  builder
Â  Â  Â  .setNomeDeUsuario("user_padrao")
Â  Â  Â  .setEmail("padrao@email.com")
Â  Â  Â  .setSenha("123456")
Â  Â  Â  .setDataCadastro(new Date());
Â  }
}
```

**Passo 3:** O Uso

```
const diretor = new Director();
const competicaoBuilder = new CompeticaoBuilder();
const adminUser: Usuario = ... 

diretor.buildCompeticao(competicaoBuilder);

const competicaoPadrao = competicaoBuilder
    .setAdmin(adminUser)
    .setValidacaoMinima(3)
    .getResult(); 

diretor.buildCompeticao(competicaoBuilder);

const maratona = competicaoBuilder
    .setNome("Maratona de VerÃ£o") 
    .setDuracao(30)               
    .setAdmin(adminUser)
    .setValidacaoMinima(5)
    .getResult();
```

---

## Resumo da Abordagem no Projeto

A tabela a seguir resume qual estrutura de Builder Ã© recomendada para cada entidade:

|   Entidade  | Estrutura Recomendada         | Justificativa|
| ----------- | ----------------------------- | -------------|
|  `Usuario`  | Builder Fluente Encapsulado   | CriaÃ§Ã£o flexÃ­vel. O cliente (ex: serviÃ§o de autenticaÃ§Ã£o) sabe quais dados opcionais (bio, foto) estÃ£o disponÃ­veis. Garante encapsulamento. |
|  `Receita`  | Builder Fluente Encapsulado   | CriaÃ§Ã£o flexÃ­vel. O cliente (ex: formulÃ¡rio de receita) fornece os dados passo a passo. Garante encapsulamento.|
|`Competicao` | Fluente + `Diretor` Stateless | O Diretor Ã© usado para criar "presets" (Desafio DiÃ¡rio, Maratona Mensal), simplificando a vida do usuÃ¡rio admin. |

--- 

## ReferÃªncias

---

## HistÃ³rico de VersÃ£o

| VersÃ£o | Data | AlteraÃ§Ã£o | ResponsÃ¡vel | Revisor | Data de revisÃ£o |
| ------ | ---- | --------- | ----------- | ------- | --------------- |
| 1.0    | 22/10/2025 | CriaÃ§Ã£o do documento e conteÃºdo. | Joao Pedro Ferreira Moraes | | |